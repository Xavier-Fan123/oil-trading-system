# Secrets Rotation and Management Configuration
# Automated secrets rotation for enhanced security

---
# CronJob for Database Password Rotation
apiVersion: batch/v1
kind: CronJob
metadata:
  name: rotate-database-password
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: secrets-rotation
    target: database
spec:
  schedule: "0 2 1 * *"  # Monthly on 1st at 2 AM
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: secrets-rotation
            target: database
        spec:
          serviceAccountName: secrets-rotation
          restartPolicy: OnFailure
          containers:
          - name: password-rotator
            image: postgres:15-alpine
            command:
            - /bin/sh
            - -c
            - |
              # Generate new password
              NEW_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
              
              # Update password in PostgreSQL
              PGPASSWORD=$OLD_PASSWORD psql -h postgresql -U postgres -d OilTradingDb -c "ALTER USER postgres PASSWORD '$NEW_PASSWORD';"
              
              # Update Vault with new password
              vault write secret/oil-trading/database password=$NEW_PASSWORD
              
              # Wait for External Secrets to sync
              sleep 60
              
              # Restart API pods to pick up new password
              kubectl rollout restart deployment/oil-trading-api -n oil-trading
              
              echo "Database password rotation completed successfully"
            env:
            - name: OLD_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: oil-trading-database-secrets
                  key: database-password
            - name: VAULT_ADDR
              value: "https://vault.production.example.com"
            - name: VAULT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: vault-token
                  key: token
            resources:
              limits:
                memory: "256Mi"
                cpu: "200m"
              requests:
                memory: "128Mi"
                cpu: "100m"

---
# CronJob for JWT Secret Rotation
apiVersion: batch/v1
kind: CronJob
metadata:
  name: rotate-jwt-secret
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: secrets-rotation
    target: jwt
spec:
  schedule: "0 3 15 * *"  # Mid-month at 3 AM
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: secrets-rotation
            target: jwt
        spec:
          serviceAccountName: secrets-rotation
          restartPolicy: OnFailure
          containers:
          - name: jwt-rotator
            image: vault:latest
            command:
            - /bin/sh
            - -c
            - |
              # Generate new JWT secret
              NEW_JWT_SECRET=$(openssl rand -base64 64 | tr -d "=+/" | cut -c1-32)
              
              # Update Vault with new JWT secret
              vault write secret/oil-trading/auth jwt-secret=$NEW_JWT_SECRET
              
              # Wait for External Secrets to sync
              sleep 60
              
              # Rolling restart API pods to pick up new secret
              kubectl rollout restart deployment/oil-trading-api -n oil-trading
              
              echo "JWT secret rotation completed successfully"
            env:
            - name: VAULT_ADDR
              value: "https://vault.production.example.com"
            - name: VAULT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: vault-token
                  key: token
            resources:
              limits:
                memory: "128Mi"
                cpu: "100m"
              requests:
                memory: "64Mi"
                cpu: "50m"

---
# CronJob for TLS Certificate Renewal
apiVersion: batch/v1
kind: CronJob
metadata:
  name: renew-tls-certificates
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: secrets-rotation
    target: tls
spec:
  schedule: "0 1 * * 0"  # Weekly on Sunday at 1 AM
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: secrets-rotation
            target: tls
        spec:
          serviceAccountName: secrets-rotation
          restartPolicy: OnFailure
          containers:
          - name: cert-renewer
            image: certbot/certbot:latest
            command:
            - /bin/sh
            - -c
            - |
              # Check certificate expiry
              CERT_EXPIRY=$(openssl x509 -enddate -noout -in /etc/ssl/certs/tls.crt | cut -d= -f2)
              EXPIRY_TIMESTAMP=$(date -d "$CERT_EXPIRY" +%s)
              CURRENT_TIMESTAMP=$(date +%s)
              DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_TIMESTAMP - $CURRENT_TIMESTAMP) / 86400 ))
              
              echo "Certificate expires in $DAYS_UNTIL_EXPIRY days"
              
              # Renew if less than 30 days
              if [ $DAYS_UNTIL_EXPIRY -lt 30 ]; then
                echo "Renewing certificate..."
                # Add certificate renewal logic here
                # This would typically integrate with Let's Encrypt or your CA
                echo "Certificate renewal completed"
              else
                echo "Certificate renewal not needed"
              fi
            volumeMounts:
            - name: tls-certs
              mountPath: /etc/ssl/certs
              readOnly: true
            resources:
              limits:
                memory: "128Mi"
                cpu: "100m"
              requests:
                memory: "64Mi"
                cpu: "50m"
          volumes:
          - name: tls-certs
            secret:
              secretName: oil-trading-tls

---
# Service Account for Secrets Rotation
apiVersion: v1
kind: ServiceAccount
metadata:
  name: secrets-rotation
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: secrets-rotation

---
# Role for Secrets Rotation
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secrets-rotation-role
  namespace: oil-trading
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments/scale"]
  verbs: ["get", "update", "patch"]

---
# RoleBinding for Secrets Rotation
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: secrets-rotation-binding
  namespace: oil-trading
subjects:
- kind: ServiceAccount
  name: secrets-rotation
  namespace: oil-trading
roleRef:
  kind: Role
  name: secrets-rotation-role
  apiGroup: rbac.authorization.k8s.io

---
# Secret for Vault Token (for rotation jobs)
apiVersion: v1
kind: Secret
metadata:
  name: vault-token
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: vault-auth
type: Opaque
data:
  # This should be populated by CI/CD or manual setup
  token: ""  # Base64 encoded Vault token with rotation permissions

---
# Monitoring for Secrets Rotation
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: secrets-rotation-monitor
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: monitoring
spec:
  selector:
    matchLabels:
      app: secrets-rotation
  endpoints:
  - port: metrics
    path: /metrics
    interval: 30s

---
# Alert Rules for Secrets Rotation
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: secrets-rotation-alerts
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: alerts
spec:
  groups:
  - name: secrets-rotation
    rules:
    - alert: SecretRotationFailed
      expr: increase(kube_job_failed_total{job_name=~"rotate-.*"}[1h]) > 0
      for: 0m
      labels:
        severity: critical
        component: secrets-rotation
      annotations:
        summary: "Secret rotation job failed"
        description: "Secret rotation job {{ $labels.job_name }} has failed"
    
    - alert: CertificateExpiryWarning
      expr: (cert_expiry_timestamp - time()) / 86400 < 30
      for: 1h
      labels:
        severity: warning
        component: certificates
      annotations:
        summary: "TLS certificate expiring soon"
        description: "TLS certificate for {{ $labels.domain }} expires in {{ $value }} days"
    
    - alert: CertificateExpiryCritical
      expr: (cert_expiry_timestamp - time()) / 86400 < 7
      for: 0m
      labels:
        severity: critical
        component: certificates
      annotations:
        summary: "TLS certificate expiring very soon"
        description: "TLS certificate for {{ $labels.domain }} expires in {{ $value }} days"

---
# Emergency Secrets Backup Job
apiVersion: batch/v1
kind: Job
metadata:
  name: backup-secrets-emergency
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: emergency-backup
spec:
  template:
    metadata:
      labels:
        app: emergency-backup
    spec:
      serviceAccountName: secrets-rotation
      restartPolicy: OnFailure
      containers:
      - name: backup
        image: vault:latest
        command:
        - /bin/sh
        - -c
        - |
          echo "Creating emergency backup of critical secrets..."
          
          # Backup database credentials
          vault read -field=password secret/oil-trading/database > /backup/db-password.txt
          
          # Backup JWT secret
          vault read -field=jwt-secret secret/oil-trading/auth > /backup/jwt-secret.txt
          
          # Create encrypted archive
          tar -czf /backup/secrets-backup-$(date +%Y%m%d-%H%M%S).tar.gz /backup/*.txt
          
          # Clean up plain text files
          rm /backup/*.txt
          
          echo "Emergency backup completed"
        env:
        - name: VAULT_ADDR
          value: "https://vault.production.example.com"
        - name: VAULT_TOKEN
          valueFrom:
            secretKeyRef:
              name: vault-token
              key: token
        volumeMounts:
        - name: backup-storage
          mountPath: /backup
        resources:
          limits:
            memory: "256Mi"
            cpu: "200m"
          requests:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: backup-storage
        persistentVolumeClaim:
          claimName: secrets-backup-pvc

---
# PersistentVolumeClaim for Secrets Backup
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: secrets-backup-pvc
  namespace: oil-trading
  labels:
    app: oil-trading-system
    component: backup-storage
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: encrypted-ssd